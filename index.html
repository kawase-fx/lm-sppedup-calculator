<html lang="ja">
  <head>
    <style>
      .view { display: block; }
      .scaled { display: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/big-js@3.1.3/big.min.js"></script>
    <script src="https://unpkg.com/tesseract.js@v2.0.2/dist/tesseract.min.js"></script>
  </head>
  <body>
    <div>
      <input type="file" id="image_zone" multiple="multiple" accept="image/*">
      <span id="stat">readied.</span><progress id="p" value="0" max="100">0%</progress>
    </div>
    <div><textarea id="output" rows="20" cols="60" style='font-size: 10pt;'></textarea></div>
    <div id='gallery'></div>
    <script>
      const _d = document, LANG = 'jpn', THRESHOLD = 120, SCALE = 4, MI = 60, HR = MI * 60, DY = HR * 24;
      const _i = v => _d.getElementById( v );
      const imageZone = _i( 'image_zone' ), p = _i( 'p' ), stat = _i( 'stat' );
      const RECT_TABLE = [
        [ 0.1875, 0.2704, 0.2604, 0.037 ,1 ], [ 0.1, 0.3926, 0.0938, 0.037, 1 ],
        [ 0.1875, 0.4685, 0.2604, 0.037, 2 ], [ 0.1, 0.5926, 0.0938, 0.037, 2 ],
        [ 0.1875, 0.6685, 0.2604, 0.037, 3 ], [ 0.1, 0.7926, 0.0938, 0.037, 3 ]
      ];

      const CVT = {
        ' ': '', '\n': '', '。': '', '_': '', 'い': '', '攻': '数', 'ピードピード': 'ピード',
        '①': '1', '②': '2', '③': '3', '④': '4', '⑤': '5',
        '⑥': '6', '⑦': '7', '⑧': '8', '⑨': '9',
        '⑪': '11', '⑫': '12', '⑮': '15',
        '⑲': '19', '⑳': '20',
        '所持数:': '', '.': '', ',': '', '修復': '',
      };
      const GENRES = [ '汎用', '研究', '城壁', '治療', '訓練', '精製', '錬成' ];
      const UNITS = [ '1分', '3分', '5分', '10分', '15分', '30分', '60分', '3時間', '8時間', '15時間', '24時間', '3日', '7日', '30日' ];

      globalThis.T = {}, globalThis.S = {};

      const sleep = msec => new Promise( resolve => setTimeout( resolve, msec ) );

      const s2dhms = s => {
        let m = s, r = {};
        r.d = Math.floor( s / DY ); m -= r.d * DY;
        r.h = Math.floor( m / HR ); m -= r.h * HR;
        r.m = Math.floor( m / MI ); m -= r.m * MI;
        r.s = m; r.ja = `${ r.d }日${ r.h }時間${ r.m }分`;
        return r;
      }

      const loadImage = i => { return new Promise( ( resolve, reject ) => {
        const r = new FileReader();
        r.onload = () => {
          const i = new Image();
          i.onload = () => resolve( i );
          i.onerror = e => reject( e );
          i.src = r.result;
        }
        r.onerror = e => reject( e );
        r.readAsDataURL( i );
      } ); }

      const jnl = m => {
        let pct = Big( m.progress ).mul( 100 ).toFixed( 2 );
        stat.textContent = `${ m.status }: ${ pct }%`; p.setAttribute( 'value', Number( pct ) );
      }

      const i2c = ( a, x, scale ) => {
        let __c = _d.createElement( 'canvas' );
        if( scale ) {
          __c.id = `${ Date.now() }`;
          __c.setAttribute( 'class', 'scaled' );
          T[ __c.id ] = {};
        } else {
          __c.setAttribute( 'class', 'view' );
        }
        _i( 'gallery' ).append( __c );
        let ctx = __c.getContext( '2d' );
        let [ sx, sy, sw, sh ] = [ a[ 0 ] * x.width, a[ 1 ] * x.height, a[ 2 ] * x.width, a[ 3 ] * x.height ];
        if( scale ) {
          __c.width = sw * scale, __c.height = sh * scale; ctx.scale( scale, scale );
        }
        ctx.drawImage( x, sx, sy, sw, sh, 0, 0, sw, sh );
        let src = ctx.getImageData( 0, 0, __c.width, __c.height );
        let d = src.data;
        for( let i = 0; i < d.length; i += 4 ) {
          let b = 0.34 * d[ i ] + 0.5 * d[ i + 1 ] + 0.16 * d[ i + 2 ]; b = b > THRESHOLD ? b + 32 : 0;
          d[ i ] = b; d[ i + 1 ] = b; d[ i + 2 ] = b;
        }
        ctx.putImageData( src, 0, 0 );
        return __c;
      }

      const recogMain = async ( a, x ) => {
        let __c = i2c( a, x, SCALE );
        let rr = ( await Tesseract.recognize( __c, LANG, { logger: jnl } ) ).data.text;
        Object.keys( CVT ).map( e => { rr = rr.split( e ).join( CVT[ e ] ); } );
        T[ __c.id ] = rr;
        return rr;
      }

      const imageToCanvas = async file => {
        let x = await loadImage( file );
        RECT_TABLE.map( async a => {
          let rr = await recogMain( a, x );
        } );
      }

      const recognize = async e => {
        [ ... e.target.files ].map( async f => await imageToCanvas( f ) );

        await sleep( 2e3 );

        let mj = setInterval( () => {
          let l = Object.keys( T ).sort( ( a, b ) => a - b );
          let s = l.length > 0 && l.filter( e => Object.keys( T[ e ] ).length === 0 ).length === 0;
          if( s ) {
            S = {}; let rs = [], ts = Object.entries( T ).map( e => e[ 1 ] );
            for( let si = 0; si < ts.length; si += 2 ) {
              let f = 1, kv = ts[ si ].split( 'スピードアップ' );
              let v = kv[ 1 ].replace( /[分時間日]+/, '' );
              if( kv[ 1 ].indexOf( '分' ) > -1 ) f *= MI;
              if( kv[ 1 ].indexOf( '時間' ) > -1 ) f *= HR;
              if( kv[ 1 ].indexOf( '日' ) > -1 ) f *= DY;

              if( kv[ 0 ] === '' ) kv[ 0 ] = '汎用';
              if( !S[ kv[ 0 ] ] ) S[ kv[ 0 ] ] = [];
              let sc = v * f * ts[ si + 1 ];
              S[ kv[ 0 ] ][ kv[ 1 ] ] = { sec: sc, nums: ts[ si + 1 ] };
            }
            Object.keys( S ).map( k => {
              let kt = Object.keys( S[ k ] ).map( e => S[ k ][ e ].sec ).reduce( ( acc, cur ) => acc + cur );
              _i( 'output' ).value += `${ k }:${ s2dhms( kt ).ja }\n`;
              // _i( 'output' ).value += `内訳:\n`;
              // S[ k ].map( e => { _i( 'output' ).value += `${ e.unit }:${ e.nums }個=${ s2dhms( e.sec ).ja }\n` } );
            } );
            clearInterval( mj );
            stat.textContent = 'done.'
          } else {
            _i( 'output' ).value = '';
          }
        } );
      }

      imageZone.addEventListener( 'change', recognize, false );

    </script>

</body></html>
